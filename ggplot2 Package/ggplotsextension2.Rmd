---
title: "GGplot2 Extension2"
author: "David Asare Kumi"
date: "4/14/2020"
output: html_document
---


## Positioning

### Introduction

- This chapter discusses position, particularly how facets are laid out on a page, and how coordinate systems within a panel work. There are four components that control position. You have already learned about two of them that work within a facet:

1. Position adjustments adjust the position of overlapping objects within a layer. These are most useful for bar and other interval geoms, but can be useful in other situations (Sect. 5.7).

2. Position scales control how the values in the data are mapped to positions on the plot (Sect. 6.6.1). This chapter will describe the other two components and show you how
all four pieces fit together:

3. Facetting is a mechanism for automatically laying out multiple plots on a page. It splits the data into subsets, and then plots each subset in a different panel. Such plots are often called small multiples or trellis graphics (Sect. 7.2).

4. Coordinate systems control how the two independent position scales are combined to create a 2d coordinate system. The most common coordinate system is Cartesian, but other coordinate systems can be useful in special circumstances (Sect. 7.3).

## Facetting

- You first encountered facetting in Sect. 2.5. Facetting generates small multiples each showing a different subset of the data. Small multiples are a powerful tool for exploratory data analysis: you can rapidly compare patterns in different parts of the data and see whether they are the same or different.

- This section will discuss how you can fine-tune facets, particularly the way
in which they interact with position scales.

- There are three types of facetting:

1. facet null(): a single plot, the default.

2. facet wrap(): “wraps” a 1d ribbon of panels into 2d.

3. facet grid(): produces a 2d grid of panels defined by variables which form the rows and columns.

- Faceted plots have the capability to fill up a lot of space, so for this chapter we will use a subset of the mpg dataset that has a manageable number of levels: three cylinders (4, 6, 8), two types of drive train (4 and f), and six classes.

- mpg2 <- subset(mpg, cyl != 5 & drv %in% c("4", "f") & class != "2seater").

## Facet Wrap

- facet wrap() makes a long ribbon of panels (generated by any number of variables) and wraps it into 2d. This is useful if you have a single variable with many levels and want to arrange the plots in a more space efficient manner.

- You can control how the ribbon is wrapped into a grid with ncol, nrow, as.table and dir. ncol and nrow control how many columns and rows (you only need to set one). as.table controls whether the facets are laid out like a table (TRUE), with highest values at the bottom-right, or a plot (FALSE), with the highest values at the top-right. dir controls the direction of wrap: horizontal or vertical.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

mpg2 <- subset(mpg, cyl != 5 & drv %in% c("4", "f") & class != "2seater")

base <- ggplot(mpg2, aes(displ, hwy)) +
geom_blank() +
xlab(NULL) +
ylab(NULL)

base + facet_wrap(~class, ncol = 3)
base + facet_wrap(~class, ncol = 3, as.table = FALSE)
base + facet_wrap(~class)
base + facet_wrap(~class, nrow = 3)
base + facet_wrap(~class, nrow = 3, dir = "v")

```


## Facet Grid

- facet grid() lays out plots in a 2d grid, as defined by a formula:

1. . ~ a spreads the values of a across the columns. This direction facilitates comparisons of y position, because the vertical scales are aligned.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

base + facet_grid(. ~ cyl)


```


2. b ~ . spreads the values of b down the rows. This direction facilitates comparison of x position because the horizontal scales are aligned. This makes it particularly useful for comparing distributions.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

base + facet_grid(drv ~ .)

```

3. a ~ b spreads a across columns and b down rows. You’ll usually want to put the variable with the greatest number of levels in the columns, to take advantage of the aspect ratio of your screen.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

base + facet_grid(drv ~ cyl)


```

- You can use multiple variables in the rows or columns, by “adding” them together, e.g. a + b ~ c + d. Variables appearing together on the rows or columns are nested in the sense that only combinations that appear in the data will appear in the plot. Variables that are specified on rows and columns
will be crossed: all combinations will be shown, including those that didn’t appear in the original dataset: this may result in empty panels.

## Controlling Scales

- For both facet wrap() and facet grid() you can control whether the position scales are the same in all panels (fixed) or allowed to vary between panels (free) with the scales parameter:

1. scales = "fixed": x and y scales are fixed across all panels.

2. scales = "free x": the x scale is free, and the y scale is fixed.

3. scales = "free y": the y scale is free, and the x scale is fixed.

4. scales = "free": x and y scales vary across panels.

- facet grid() imposes an additional constraint on the scales: all panels in a column must have the same x scale, and all panels in a row must have the same y scale. This is because each column shares an x axis, and each row shares a y axis.

- Fixed scales make it easier to see patterns across panels; free scales make it easier to see patterns within panels.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

p <- ggplot(mpg2, aes(cty, hwy)) +
geom_abline() +
geom_jitter(width = 0.1, height = 0.1)

p + facet_wrap(~cyl)

p + facet_wrap(~cyl, scales = "free")

```

- Free scales are also useful when we want to display multiple time series that were measured on different scales. To do this, we first need to change from ‘wide’ to ‘long’ data, stacking the separate variables into a single column. An example of this is shown below with the long form of the economics data, and the topic is discussed in more detail in Sect. 9.3.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

economics_long

ggplot(economics_long, aes(date, value)) +
geom_line() +
facet_wrap(~variable, scales = "free_y", ncol = 1)

```

- facet grid() has an additional parameter called space, which takes the same values as scales. When space is “free”, each column (or row) will have width (or height) proportional to the range of the scale for that column (or row). This makes the scaling equal across the whole plot: 1 cm on each panel
maps to the same range of data. (This is somewhat analogous to the ‘sliced’ axis limits of lattice.) For example, if panel a had range 2 and panel b had range 4, one-third of the space would be given to a, and two-thirds to b. This is most useful for categorical scales, where we can assign space proportionally based on the number of levels in each facet, as illustrated below.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

mpg2$model <- reorder(mpg2$model, mpg2$cty)
mpg2$manufacturer <- reorder(mpg2$manufacturer, -mpg2$cty)
ggplot(mpg2, aes(cty, model)) +
geom_point() +
facet_grid(manufacturer ~ ., scales = "free", space = "free") +
theme(strip.text.y = element_text(angle = 0))

```


## Missing Facetting Variables

- If you are using facetting on a plot with multiple datasets, what happens when one of those datasets is missing the facetting variables? This situation commonly arises when you are adding contextual information that should be the same in all panels. For example, imagine you have a spatial display of
disease faceted by gender. What happens when you add a map layer that does not contain the gender variable? Here ggplot will do what you expect: it will display the map in every facet: missing facetting variables are treated like they have all values.

- Here’s a simple example. Note how the single red point from df2 appears in both panels.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

df1 <- data.frame(x = 1:3, y = 1:3, gender = c("f", "f", "m"))
df2 <- data.frame(x = 2, y = 2)
ggplot(df1, aes(x, y)) +
geom_point(data = df2, colour = "red", size = 2) +
geom_point() +
facet_wrap(~gender)

```

- This technique is particularly useful when you add annotations to make it easier to compare between facets, as shown in the next section.

## Grouping vs. Facetting

- Facetting is an alternative to using aesthetics (like colour, shape or size) to differentiate groups. Both techniques have strengths and weaknesses, based around the relative positions of the subsets. With facetting, each group is quite far apart in its own panel, and there is no overlap between the groups. This is good if the groups overlap a lot, but it does make small differences
harder to see. When using aesthetics to differentiate groups, the groups are close together and may overlap, but small differences are easier to see.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

df <- data.frame(
x = rnorm(120, c(0, 2, 4)),
y = rnorm(120, c(1, 2, 1)),
z = letters[1:3]
)

ggplot(df, aes(x, y)) +
geom_point(aes(colour = z))

ggplot(df, aes(x, y)) +
geom_point() +
facet_wrap(~z)

```

- Comparisons between facets often benefit from some thoughtful annotation. For example, in this case we could show the mean of each group in every panel. You’ll learn how to write summary code like this in Chap. 10. Note that we need two “z” variables: one for the facets and one for the colours.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

df_sum <- df %>%
group_by(z) %>%
summarise(x = mean(x), y = mean(y)) %>%
rename(z2 = z)
ggplot(df, aes(x, y)) +
geom_point() +
geom_point(data = df_sum, aes(colour = z2), size = 4) +
facet_wrap(~z)

```

- Another useful technique is to put all the data in the background of each panel:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

df2 <- dplyr::select(df, -z)
ggplot(df, aes(x, y)) +
geom_point(data = df2, colour = "grey70") +
geom_point(aes(colour = z)) +
facet_wrap(~z)

```


## Continuous Variables

- To facet continuous variables, you must first discretise them. ggplot2 provides three helper functions to do so:

1. Divide the data into n bins each of the same length: cut interval(x, n).

2. Divide the data into bins of width width: cut width(x, width).

3. Divide the data into n bins each containing (approximately) the same number of points: cut number(x, n = 10).

They are illustrated below:


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

# Bins of width 1
mpg2$disp_w <- cut_width(mpg2$displ, 1)

# Six bins of equal length
mpg2$disp_i <- cut_interval(mpg2$displ, 6)

# Six bins containing equal numbers of points
mpg2$disp_n <- cut_number(mpg2$displ, 6)
plot <- ggplot(mpg2, aes(cty, hwy)) +
geom_point() +
labs(x = NULL, y = NULL)
plot + facet_wrap(~disp_w, nrow = 1)

plot + facet_wrap(~disp_i, nrow = 1)

plot + facet_wrap(~disp_n, nrow = 1)

```

- Note that the facetting formula does not evaluate functions, so you must first create a new variable containing the discretised data.

## Coordinate Systems

- Coordinate systems have two main jobs:

1. Combine the two position aesthetics to produce a 2d position on the plot. The position aesthetics are called x and y, but they might be better called position 1 and 2 because their meaning depends on the coordinate system used. For example, with the polar coordinate system they become angle and radius (or radius and angle), and with maps they become latitude and longitude.

2. In coordination with the faceter, coordinate systems draw axes and panel backgrounds. While the scales control the values that appear on the axes, and how they map from data to position, it is the coordinate system which actually draws them. This is because their appearance depends on the
coordinate system: an angle axis looks quite different than an x axis.

- There are two types of coordinate system. Linear coordinate systems preserve the shape of geoms:

1. coord cartesian(): the default Cartesian coordinate system, where the 2d position of an element is given by the combination of the x and y positions.

2. coord flip(): Cartesian coordinate system with x and y axes flipped.

3. coord fixed(): Cartesian coordinate system with a fixed aspect ratio.

- On the other hand, non-linear coordinate systems can change the shapes: a straight line may no longer be straight. The closest distance between two points may no longer be a straight line.

1. coord map()/coord quickmap(): Map projections.

2. coord polar(): Polar coordinates.

3. coord trans(): Apply arbitrary transformations to x and y positions, after the data has been processed by the stat.

- Each coordinate system is described in more detail below.

## Linear Coordinate Systems

- There are three linear coordinate systems: coord cartesian(), coord flip(), coord fixed().


### Zooming into a Plot with coord cartesian()

- coord cartesian() has arguments xlim and ylim. If you think back to the scales chapter, you might wonder why we need these. Doesn’t the limits argument of the scales already allow us to control what appears on the plot? The key difference is how the limits work: when setting scale limits, any data outside the limits is thrown away; but when setting coordinate system limits we still use all the data, but we only display a small region of the plot. Setting coordinate system limits is like looking at the plot under a magnifying glass.


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

base <- ggplot(mpg, aes(displ, hwy)) +
geom_point() +
geom_smooth()
# Full dataset
g1<-base
# Scaling to 5--7 throws away data outside that range
g2<-base + scale_x_continuous(limits = c(5, 7))
g3<-base + coord_cartesian(xlim = c(5, 7))

grid.arrange(g1,g2,g3,ncol=3)

```

## Flipping the Axes with coord flip()

- Most statistics and geoms assume you are interested in y values conditional on x values (e.g., smooth, summary, boxplot, line): in most statistical models, the x values are assumed to be measured without error. If you are interested in x conditional on y (or you just want to rotate the plot 90 degrees), you can use coord flip() to exchange the x and y axes. Compare this with just exchanging the variables mapped to x and y:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

g1<-ggplot(mpg, aes(displ, cty)) +
geom_point() +
geom_smooth()

# Exchanging cty and displ rotates the plot 90 degrees, but the smooth
# is fit to the rotated data.
g2<-ggplot(mpg, aes(cty, displ)) +
geom_point() +
geom_smooth()

# coord_flip() fits the smooth to the original data, and then rotates
# the output
g3<-ggplot(mpg, aes(displ, cty)) +
geom_point() +
geom_smooth() +
coord_flip()

grid.arrange(g1,g2,g3,ncol=3)

```

## Equal Scales with coord fixed()

- coord fixed() fixes the ratio of length on the x and y axes. The default ratio ensures that the x and y axes have equal scales: i.e., 1 cm along the x axis represents the same range of data as 1 cm along the y axis. The aspect ratio will also be set to ensure that the mapping is maintained regardless of the shape of the output device. See the documentation of coord fixed() for more
details.

## Non-linear Coordinate Systems

- Unlike linear coordinates, non-linear coordinates can change the shape of geoms. For example, in polar coordinates a rectangle becomes an arc; in a map projection, the shortest path between two points is not necessarily a straight line. The code below shows how a line and a rectangle are rendered in a few different coordinate systems.


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

rect <- data.frame(x = 50, y = 50)
line <- data.frame(x = c(1, 200), y = c(100, 1))
base <- ggplot(mapping = aes(x, y)) +
geom_tile(data = rect, aes(width = 50, height = 50)) +
geom_line(data = line) +
xlab(NULL) + ylab(NULL)
g1<-base
g2<-base + coord_polar("x")
g3<-base + coord_polar("y")

g4<-base + coord_flip()
g5<-base + coord_trans(y = "log10")
g6<-base + coord_fixed()

grid.arrange(g1,g2,g3,g4,g5,g6,ncol=3,nrow=2)

```

- The transformation takes part in two steps. Firstly, the parameterisation of each geom is changed to be purely location-based, rather than locationand dimension-based. For example, a bar can be represented as an x position (a location), a height and a width (two dimensions). Interpreting height and width in a non-Cartesian coordinate system is hard because a rectangle may no longer have constant height and width, so we convert to a purely locationbased representation, a polygon defined by the four corners. This effectively converts all geoms to a combination of points, lines and polygons.

- Once all geoms have a location-based representation, the next step is to transform each location into the new coordinate system. It is easy to transform points, because a point is still a point no matter what coordinate system you are in. Lines and polygons are harder, because a straight line may
no longer be straight in the new coordinate system. To make the problem tractable we assume that all coordinate transformations are smooth, in the sense that all very short lines will still be very short straight lines in the new coordinate system. With this assumption in hand, we can transform lines and
polygons by breaking them up into many small line segments and transforming each segment. This process is called munching and is illustrated below:


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

#1. We start with a line parameterised by its two endpoints:
df <- data.frame(r = c(0, 1), theta = c(0, 3 / 2 * pi))
ggplot(df, aes(r, theta)) +
geom_line() +
geom_point(size = 2, colour = "red")

#2. We break it into multiple line segments, each with two endpoints.
interp <- function(rng, n) {
seq(rng[1], rng[2], length = n)
}
munched <- data.frame(
r = interp(df$r, 15),
theta = interp(df$theta, 15)
)
ggplot(munched, aes(r, theta)) +
geom_line() +
geom_point(size = 2, colour = "red")

#3. We transform the locations of each piece:
transformed <- transform(munched,
x = r * sin(theta),
y = r * cos(theta)
)
ggplot(transformed, aes(x, y)) +
geom_path() +
geom_point(size = 2, colour = "red") +
coord_fixed()


```

- Internally ggplot2 uses many more segments so that the result looks smooth.


## Transformations with coord trans()

- Like limits, we can also transform the data in two places: at the scale level or at the coordinate system level. coord trans() has arguments x and y which should be strings naming the transformer or transformer objects (see Sect. 6.6.1). Transforming at the scale level occurs before statistics are
computed and does not change the shape of the geom. Transforming at the coordinate system level occurs after the statistics have been computed, and does affect the shape of the geom. Using both together allows us to model the data on a transformed scale and then backtransform it for interpretation:
a common pattern in analysis.


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

# Linear model on original scale is poor fit
base <- ggplot(diamonds, aes(carat, price)) +
stat_bin2d() +
geom_smooth(method = "lm") +
xlab(NULL) +
ylab(NULL) +
theme(legend.position = "none")
base

# Better fit on log scale, but harder to interpret
base +
scale_x_log10() +
scale_y_log10()

# Fit on log scale, then backtransform to original.
# Highlights lack of expensive diamonds with large carats
pow10 <- scales::exp_trans(10)
base +
scale_x_log10() +
scale_y_log10() +
coord_trans(x = pow10, y = pow10)

```

## Polar Coordinates with coord polar()

- Using polar coordinates gives rise to pie charts and wind roses (from bar geoms), and radar charts (from line geoms). Polar coordinates are often used for circular data, particularly time or direction, but the perceptual properties are not good because the angle is harder to perceive for small radii than it is for large radii. The theta argument determines which position variable is
mapped to angle (by default, x) and which to radius.

- The code below shows how we can turn a bar into a pie chart or a bullseye chart by changing the coordinate system. The documentation includes other examples.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

base <- ggplot(mtcars, aes(factor(1), fill = factor(cyl))) +
geom_bar(width = 1) +
theme(legend.position = "none") +
scale_x_discrete(NULL, expand = c(0, 0)) +
scale_y_continuous(NULL, expand = c(0, 0))

# Stacked barchart
g1<-base

# Pie chart
g2<-base + coord_polar(theta = "y")

# The bullseye chart
g3<-base + coord_polar()

grid.arrange(g1,g2,g3,ncol=3)

```

## Map Projections with coord map()

- Maps are intrinsically displays of spherical data. Simply plotting raw longitudes and latitudes is misleading, so we must project the data. There are two ways to do this with ggplot2:

1. coord quickmap() is a quick and dirty approximation that sets the aspect ratio to ensure than 1m of latitude and 1m of longitude are the same distance in the middle of the plot. These is a reasonable place to start for smaller regions, and is very faster.


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(directlabels)
library(wesanderson)

# Prepare a map of NZ
nzmap <- ggplot(map_data("nz"), aes(long, lat, group = group)) +
geom_polygon(fill = "white", colour = "black") +
xlab(NULL) + ylab(NULL)

# Plot it in cartesian coordinates
g1<-nzmap

# With the aspect ratio approximation
g2<-nzmap + coord_quickmap()

grid.arrange(g1,g2,ncol=2)


```

2. • coord map() uses the mapproj package, https://cran.r-project.org/ package=mapproj to do a formal map projection. It takes the same arguments as mapproj::mapproject() for controlling the projection. It is much slower than coord quickmap() because it must munch the data and transform each piece.


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)

world <- map_data("world")
worldmap <- ggplot(world, aes(long, lat, group = group)) +
geom_path() +
scale_y_continuous(NULL, breaks = (-2:3) * 30, labels = NULL) +
scale_x_continuous(NULL, breaks = (-4:4) * 45, labels = NULL)

g1<-worldmap + coord_map()

# Some crazier projections
g2<-worldmap + coord_map("ortho")

g3<-worldmap + coord_map("stereographic")

grid.arrange(g1,g2,g3,ncol=3)

```

## Themes

### Introduction

- In this chapter you will learn how to use the ggplot2 theme system, which allows you to exercise fine control over the non-data elements of your plot. The theme system does not affect how the data is rendered by geoms, or how it is transformed by scales. Themes don’t change the perceptual properties of the plot, but they do help you make the plot aesthetically pleasing or match an existing style guide. Themes give you control over things like fonts, ticks, panel strips, and backgrounds.

- This separation of control into data and non-data parts is quite different from base and lattice graphics. In base and lattice graphics, most functions take a large number of arguments that specify both data and non-data appearance, which makes the functions complicated and harder to learn. ggplot2
takes a different approach: when creating the plot you determine how the data is displayed, then after it has been created you can edit every detail of the rendering, using the theming system.

- The theming system is composed of four main components:

1. Theme elements specify the non-data elements that you can control. For example, the plot.title element controls the appearance of the plot title; axis.ticks.x, the ticks on the x axis; legend.key.height, the height of the keys in the legend.

2. Each element is associated with an element function, which describes the visual properties of the element. For example, element text() sets the font size, colour and face of text elements like plot.title.

3. The theme() function which allows you to override the default theme elements by calling element functions, like theme(plot.title = element text(colour = "red")).

4. Complete themes, like theme grey() set all of the theme elements to values designed to work together harmoniously.

- For example, imagine you’ve made the following plot of your data.


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)

base <- ggplot(mpg, aes(cty, hwy, color = factor(cyl))) +
geom_jitter() +
geom_abline(colour = "grey50", size = 2)
base

```

- It’s served its purpose for you: you’ve learned that cty and hwy are highly correlated, both are tightly coupled with cyl, and that hwy is always greater than cty (and the difference increases as cty increases). Now you want to share the plot with others, perhaps by publishing it in a paper. That requires some changes. First, you need to make sure the plot can stand alone by:

1. Improving the axes and legend labels.

2. Adding a title for the plot.

3. Tweaking the colour scale.

- Fortunately you know how to do that already because you’ve read Chap. 6:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)

labelled <- base +
labs(
x = "City mileage/gallon",
y = "Highway mileage/gallon",
colour = "Cylinders",
title = "Highway and city mileage are highly correlated"
) +
scale_colour_brewer(type = "seq", palette = "Spectral")
labelled

```

- Next, you need to make sure the plot matches the style guidelines of your journal:

1. The background should be white, not pale grey.

2. The legend should be placed inside the plot if there’s room.

3. Major gridlines should be a pale grey and minor gridlines should be removed.

4. The plot title should be 12 pt bold text.

- In this chapter, you’ll learn how to use the theming system to make those changes, as shown below:


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)

labelled <- base +
labs(
x = "City mileage/gallon",
y = "Highway mileage/gallon",
colour = "Cylinders",
title = "Highway and city mileage are highly correlated"
) +
scale_colour_brewer(type = "seq", palette = "Spectral")

styled <- labelled +
theme_bw() +
theme(
plot.title = element_text(face = "bold", size = 12),
legend.background = element_rect(fill = "white", size = 4, colour = "white"),
legend.justification = c(0, 1),
legend.position = c(0, 1),
axis.ticks = element_line(colour = "grey70", size = 0.2),
panel.grid.major = element_line(colour = "grey70", size = 0.2),
panel.grid.minor = element_blank()
)
styled

```

- Finally, the journal wants the figure as a 600 dpi TIFF file. You’ll learn the fine details of ggsave() in Sect. 8.5.

## Complete Themes

- ggplot2 comes with a number of built in themes. The most important is theme grey(), the signature ggplot2 theme with a light grey background and white gridlines. The theme is designed to put the data forward while supporting comparisons, following the advice of (Tufte, 2006; Brewer, 1994; Carr,
2002, 1994; Carr and Sun, 1999). We can still see the gridlines to aid in the judgement of position (Cleveland, 1993), but they have little visual impact and we can easily ‘tune’ them out. The grey background gives the plot a similar typographic colour to the text, ensuring that the graphics fit in with the flow of a document without jumping out with a bright white background. Finally, the grey background creates a continuous field of colour which ensures that the plot is perceived as a single visual entity.

- There are seven other themes built in to ggplot2 1.1.0:

1. theme bw(): a variation on theme grey() that uses a white background and thin grey grid lines.

2. theme linedraw(): A theme with only black lines of various widths on white backgrounds, reminiscent of a line drawing.

3. theme light(): similar to theme linedraw() but with light grey lines and axes, to direct more attention towards the data.

4. theme dark(): the dark cousin of theme light(), with similar line sizes but a dark background. Useful to make thin coloured lines pop out.

5. theme minimal(): A minimalistic theme with no background annotations.

6. theme classic(): A classic-looking theme, with x and y axis lines and no gridlines.

7. theme void(): A completely empty theme.



```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)

df <- data.frame(x = 1:3, y = 1:3)
base <- ggplot(df, aes(x, y)) + geom_point()
g1<-base + theme_grey() + ggtitle("theme_grey()")
g2<-base + theme_bw() + ggtitle("theme_bw()")
g3<-base + theme_linedraw() + ggtitle("theme_linedraw()")
g4<-base + theme_light() + ggtitle("theme_light()")
g5<-base + theme_dark() + ggtitle("theme_dark()")
g6<-base + theme_minimal() + ggtitle("theme_minimal()")
g7<-base + theme_classic() + ggtitle("theme_classic()")
g8<-base + theme_void() + ggtitle("theme_void()")

grid.arrange(g1,g2,g3,g4,g5,g6,g7,g8,ncol=4,nrow=2)

```

- All themes have a base size parameter which controls the base font size.
The base font size is the size that the axis titles use: the plot title is usually bigger (1.2x), and the tick and strip labels are smaller (0.8x). If you want to control these sizes separately, you’ll need to modify the individual elements as described below.

- As well as applying themes a plot at a time, you can change the default theme with theme set(). For example, if you really hate the default grey background, run theme set(theme bw()) to use a white background for all plots. You’re not limited to the themes built-in to ggplot2. Other packages, like
ggthemes by Jeffrey Arnold, add even more. Here’s a few of my favourites from ggthemes:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)
library(ggthemes)

g1<-base + theme_tufte() + ggtitle("theme_tufte()")
g2<-base + theme_solarized() + ggtitle("theme_solarized()")
g3<-base + theme_excel() + ggtitle("theme_excel()") # ;)

grid.arrange(g1,g2,g3,ncol=3)

```

- The complete themes are a great place to start but don’t give you a lot of control. To modify individual elements, you need to use theme() to override the default setting for an element with an element function.

## Modifying Theme Components

- To modify an individual theme component you use code like plot + theme(element.name = element function()). In this section you’ll learn about the basic element functions, and then in the next section, you’ll see all the elements that you can modify.

- There are four basic types of built-in element functions: text, lines, rectangles, and blank. Each element function has a set of parameters that control the appearance:

1. element text() draws labels and headings. You can control the font family, face, colour, size (in points), hjust, vjust, angle (in degrees) and lineheight (as ratio of fontcase). More details on the parameters can be found in vignette("ggplot2-specs"). Setting the font face is particularly challenging.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)
library(ggthemes)

df <- data.frame(x = 1:3, y = 1:3)
base <- ggplot(df, aes(x, y)) + geom_point()

base_t <- base + labs(title = "This is a ggplot") + xlab(NULL) + ylab(NULL)
g1<-base_t + theme(plot.title = element_text(size = 16))
g2<-base_t + theme(plot.title = element_text(face = "bold", colour = "red"))
g3<-base_t + theme(plot.title = element_text(hjust = 1))

grid.arrange(g1,g2,g3,ncol=3)

```

- You can control the margins around the text with the margin argument and margin() function. margin() has four arguments: the amount of space (in points) to add to the top, right, bottom and left sides of the text. Any elements not specified default to 0.


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)
library(ggthemes)

# The margins here look asymmetric because there are also plot margins
g1<-base_t + theme(plot.title = element_text(margin = margin()))
g2<-base_t + theme(plot.title = element_text(margin = margin(t = 10, b = 10)))
g3<-base_t + theme(axis.title.y = element_text(margin = margin(r = 10)))

grid.arrange(g1,g2,g3,ncol=3)

```

2. element line() draws lines parameterised by colour, size and linetype:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)
library(ggthemes)

g1<-base + theme(panel.grid.major = element_line(colour = "black"))
g2<-base + theme(panel.grid.major = element_line(size = 2))
g3<-base + theme(panel.grid.major = element_line(linetype = "dotted"))

grid.arrange(g1,g2,g3,ncol=3)

```

3. element rect() draws rectangles, mostly used for backgrounds, parameterised by fill colour and border colour, size and linetype.


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)
library(ggthemes)

g1<-base + theme(plot.background = element_rect(fill = "grey80", colour = NA))
g2<-base + theme(plot.background = element_rect(colour = "red", size = 2))
g3<-base + theme(panel.background = element_rect(fill = "linen"))

grid.arrange(g1,g2,g3,ncol=3)

```

4. element blank() draws nothing. Use this if you don’t want anything drawn, and no space allocated for that element. The following example uses element blank() to progressively suppress the appearance of elements we’re not interested in. Notice how the plot automatically reclaims the space previously
used by these elements: if you don’t want this to happen (perhaps because they need to line up with other plots on the page), use colour = NA, fill = NA to create invisible elements that still take up space.


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)
library(ggthemes)

g1<-base
g2<-last_plot() + theme(panel.grid.minor = element_blank())
g3<-last_plot() + theme(panel.grid.major = element_blank())

grid.arrange(g1,g2,g3,ncol=3)

g1<-last_plot() + theme(panel.background = element_blank())
g2<-last_plot() + theme(
axis.title.x = element_blank(),
axis.title.y = element_blank()
)
g3<-last_plot() + theme(axis.line = element_line(colour = "grey50"))

grid.arrange(g1,g2,g3,ncol=3)

```

5. A few other settings take grid units. Create them with unit(1, "cm") or unit(0.25, "in").

- To modify theme elements for all future plots, use theme update(). It returns the previous theme settings, so you can easily restore the original parameters once you’re done.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)
library(ggthemes)

old_theme <- theme_update(
plot.background = element_rect(fill = "lightblue3", colour = NA),
panel.background = element_rect(fill = "lightblue", colour = NA),
axis.text = element_text(colour = "linen"),
axis.title = element_text(colour = "linen")
)
base
theme_set(old_theme)
base

```


## Theme Elements

- There are around 40 unique elements that control the appearance of the plot.
They can be roughly grouped into five categories: plot, axis, legend, panel
and facet. The following sections describe each in turn.

## Plot Elements

- Some elements affect the plot as a whole:

- plot.background draws a rectangle that underlies everything else on the plot. By default, ggplot2 uses a white background which ensures that the plot is usable wherever it might end up (e.g. even if you save as a png and put on a slide with a black background).When exporting plots to use in other
systems, you might want to make the background transparent with fill = NA. Similarly, if you’re embedding a plot in a system that already has margins you might want to eliminate the built-in margins. Note that a small margin is still necessary if you want to draw a border around the plot.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)
library(ggthemes)

g1<-base + theme(plot.background = element_rect(colour = "grey50", size = 2))
g2<-base + theme(
plot.background = element_rect(colour = "grey50", size = 2),
plot.margin = margin(2, 2, 2, 2)
)
g3<-base + theme(plot.background = element_rect(fill = "lightblue"))

grid.arrange(g1,g2,g3,ncol=3)

```


## Axis Elements

- The axis elements control the appearance of the axes:

- Note that axis.text (and axis.title) comes in three forms: axis.text, axis.text.x, and axis.text.y. Use the first form if you want to modify the properties of both axes at once: any properties that you don’t explicitly set in axis.text.x and axis.text.y will be inherited from axis.text.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)
library(ggthemes)

df <- data.frame(x = 1:3, y = 1:3)
base <- ggplot(df, aes(x, y)) + geom_point()

# Accentuate the axes
g1<-base + theme(axis.line = element_line(colour = "grey50", size = 1))

# Style both x and y axis labels
g2<-base + theme(axis.text = element_text(color = "blue", size = 12))

# Useful for long labels
g3<-base + theme(axis.text.x = element_text(angle = -90, vjust = 0.5))

grid.arrange(g1,g2,g3,ncol=3)

```

- The most common adjustment is to rotate the x-axis labels to avoid long overlapping labels. If you do this, note negative angles tend to look best and you should set hjust = 0 and vjust = 1:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)
library(ggthemes)

df <- data.frame(
x = c("label", "a long label", "an even longer label"),
y = 1:3
)
base <- ggplot(df, aes(x, y)) + geom_point()
g1<-base
g2<-base +
theme(axis.text.x = element_text(angle = -30, vjust = 1, hjust = 0)) +
xlab(NULL) +
ylab(NULL)

grid.arrange(g1,g2,ncol=2)

```

## Legend Elements

- The legend elements control the appearance of all legends. You can also modify the appearance of individual legends by modifying the same elements in guide legend() or guide colourbar().

- These options are illustrated below:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)
library(ggthemes)

df <- data.frame(x = 1:4, y = 1:4, z = rep(c("a", "b"), each = 2))
base <- ggplot(df, aes(x, y, colour = z)) + geom_point()
g1<-base + theme(
legend.background = element_rect(
fill = "lemonchiffon",
colour = "grey50",
size = 1
)
)
g2<-base + theme(
legend.key = element_rect(color = "grey50"),
legend.key.width = unit(0.9, "cm"),
legend.key.height = unit(0.75, "cm")
)
g3<-base + theme(
legend.text = element_text(size = 15),
legend.title = element_text(size = 15, face = "bold")
)

grid.arrange(g1,g2,g3,ncol=3)

```

- There are four other properties that control how legends are laid out in the context of the plot (legend.position, legend.direction, legend.justification, legend.box). They are described in Sect. 6.4.2.

## Panel Elements

- Panel elements control the appearance of the plotting panels:

- The main difference between panel.background and panel.border is that the background is drawn underneath the data, and the border is drawn on top of it. For that reason, you’ll always need to assign fill = NA when overriding panel.border.


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)
library(ggthemes)

base <- ggplot(df, aes(x, y)) + geom_point()

# Modify background
g1<-base + theme(panel.background = element_rect(fill = "lightblue"))

# Tweak major grid lines
g2<-base + theme(
panel.grid.major = element_line(color = "gray60", size = 0.8)
)
# Just in one direction
g3<-base + theme(
panel.grid.major.x = element_line(color = "gray60", size = 0.8)
)

grid.arrange(g1,g2,g3,ncol=3)

```

- Note that aspect ratio controls the aspect ratio of the panel, not the overall plot:

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)
library(ggthemes)

base2 <- base + theme(plot.background = element_rect(colour = "grey50"))

# Wide screen
g1<-base2 + theme(aspect.ratio = 9 / 16)

# Long and skiny
g2<-base2 + theme(aspect.ratio = 2 / 1)

# Square
g3<-base2 + theme(aspect.ratio = 1)

grid.arrange(g1,g2,g3,ncol=3)

```

## Facetting Elements

- The following theme elements are associated with faceted ggplots:

- Element strip.text.x affects both facet wrap() or facet grid();
strip.text.y only affects facet_grid().

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)
library(ggthemes)

df <- data.frame(x = 1:4, y = 1:4, z = c("a", "a", "b", "b"))
base_f <- ggplot(df, aes(x, y)) + geom_point() + facet_wrap(~z)
g1<-base_f
g2<-base_f + theme(panel.margin = unit(0.5, "in"))
g3<-base_f + theme(
strip.background = element_rect(fill = "grey20", color = "grey80", size = 1),
strip.text = element_text(colour = "white")
)

grid.arrange(g1,g2,g3,ncol=3)

```

## Saving Your Output

- When saving a plot to use in another program, you have two basic choices of output: raster or vector:

1. Vector graphics describe a plot as sequence of operations: draw a line from (x1, y1) to (x2, y2), draw a circle at (x3, x4) with radius r. This means that they are effectively ‘infinitely’ zoomable; there is no loss of detail. The most useful vector graphic formats are pdf and svg.

2. Raster graphics are stored as an array of pixel colours and have a fixed optimal viewing size. The most useful raster graphic format is png.

- Unless there is a compelling reason not to, use vector graphics: they look better in more places. There are two main reasons to use raster graphics:

3. You have a plot (e.g. a scatterplot) with thousands of graphical objects (i.e. points). A vector version will be large and slow to render.

4. You want to embed the graphic in MS Office. MS has poor support for vector graphics (except for their own DrawingXML format which is not currently easy to make from R), so raster graphics are easier.

- There are two ways to save output from ggplot2. You can use the standard R approach where you open a graphics device, generate the plot, then close the device:


```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)
library(ggthemes)

pdf("output.pdf", width = 6, height = 6)
ggplot(mpg, aes(displ, cty)) + geom_point()
dev.off()

```

- This works for all packages, but is verbose. ggplot2 provides a convenient shorthand with ggsave():

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(ggplot2)
library(dplyr)
library(gridExtra)
library(mgcv)
library(MASS)
library(maps)
library(mapproj)
library(ggthemes)

ggplot(mpg, aes(displ, cty)) + geom_point()
ggsave("output.pdf")

```

- ggsave() is optimised for interactive use: you can use it after you’ve drawn a plot. It has the following important arguments:

1. The first argument, path, specifies the path where the image should be saved. The file extension will be used to automatically select the correct graphics device. ggsave() can produce .eps, .pdf, .svg, .wmf, .png, .jpg, .bmp, and .tiff.

2. width and height control the output size, specified in inches. If left blank, they’ll use the size of the on-screen graphics device.

3. For raster graphics (i.e. .png, .jpg), the dpi argument controls the resolution of the plot. It defaults to 300, which is appropriate for most printers, but you may want to use 600 for particularly high-resolution output, or 96 for on-screen (e.g., web) display.
See ?ggsave for more details.

## References

- Brewer CA (1994) Color use guidelines for mapping and visualization. In:
MacEachren AM, Taylor DRF (ed) Visualization in modern cartography.
Elsevier Science, Burlington, pp 123–147

- Carr D (1994) Using gray in plots. ASA Stat Comput Graph Newsl 2(5):
11–14. http://www.galaxy.gmu.edu/∼dcarr/lib/v5n2.pdf

- Carr D (2002) Graphical displays. In: El-Shaarawi AH, Piegorsch WW (ed)
Encyclopedia of environmetrics, vol 2. Wiley, New York, pp 933–960.
http://www.galaxy.gmu.edu/∼dcarr/lib/EnvironmentalGraphics.pdf

- Carr D, Ru S (1999) Using layering and perceptual grouping in statistical
graphics. ASA Stat Comput Graph Newsl 10(1):25–31

- Cleveland W (1993) A model for studying display methods of statistical
graphics. J Comput Graph Stat 2:323–64. http://stat.bell-labs.com/
doc/93.4.ps

- Tufte ER (2006) Beautiful evidence. Graphics Press, Cheshire

